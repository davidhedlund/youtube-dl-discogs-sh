#!/usr/bin/env bash
# ___________________________________________________________________________ #
# #
# plainjson -- A utility for converting JSON into plain data and back. #
# #
# #
# Licensed under the Apache License, Version 2.0 (the "License"); #
# you may not use this file except in compliance with the License. #
# You may obtain a copy of the License at #
# #
# http://www.apache.org/licenses/LICENSE-2.0 #
# #
# Unless required by applicable law or agreed to in writing, software #
# distributed under the License is distributed on an "AS IS" BASIS, #
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. #
# See the License for the specific language governing permissions and #
# limitations under the License. #
# ___________________________________________________________________________ #
# #
# #
# Copyright 2010, lhunath #
# * http://www.lhunath.com #
# * Maarten Billemont #
source bashlib

### Parse JSON input data and output data in a format that's easily parsed by a bash while-read loop.
#
# The output describes the JSON hierarchy. Objects are preceded by a dot (.), array indices are preceded by a hash (#) and values are preceded by an equal sign (=).
# By default, the output will be line-based (each element in the hierarchy terminated by a newline).
# If your data contains newlines or you want a safer output format, consider -z or -d to change the delimitor.
# If this code parses your JSON incorrectly, turn on verbose mode with -v, fix the script and let me know: lhunath@lyndir.com


# Default configuration.
delimitor=$'\n'

# Options to change configuration.
while getopts :zd:vo arg; do
case $arg in
        z) delimitor='\0';;
        d) delimitor=$OPTARG;;
        v) _logVerbosity=3;;
        o) jsonout=1;;
    esac
done

# Utilities.
isObject() {
    local context=$1

    [[ $context = [^0-9]* ]]
}
isArray() {
    local context=$1

    ! isObject "$context"
}
pushContext() {
    contextStack+=("$1")
}
popContext() {
    local topIndex=$(( ${#contextStack[@]} - 1 ))

    unset 'contextStack[topIndex]'
}
peekContext() {
    local topIndex=$(( ${#contextStack[@]} - 1 ))

    printf '%s' "${contextStack[topIndex]}"
}
writeData() {
    local type

    # Check if we have anything new to show
    (( dirty )) && {
        for context in "${contextStack[@]}"; do
            # Is this context element an object(.) or array(#)?
            isObject "$context" && type='.' || type='#'

            printf '%s%s' "$type" "$context"
        done

printf "=%s${delimitor:-\0}" "$data"
    }

    data=
    dirty=0
}
parseJSON() {
    dirty=1
    # Read loop.
    while IFS= read -r -d '' -n1 char; do

if [[ $char = '"' ]]; then
if (( quoted = !quoted )); then
dbg "Quotes start."
            else
dbg "Quotes end: %s" "$data"
            fi
continue
fi

if (( ! quoted )); then
if [[ $char = '{' ]]; then
dbg "Object starts."

                dirty=1
                continue
elif [[ $char = '}' ]]; then
dbg "Object ends: %s" "$(peekContext)"

                writeData
                popContext
                continue
elif [[ $char = '[' ]]; then
dbg "Array starts."

                pushContext 0
                continue
elif [[ $char = ']' ]]; then
dbg "Array ends: %s" "$(peekContext)"

                writeData
                popContext
                continue
elif [[ $char = ':' ]]; then
dbg "Key: %s" "$data"

                pushContext "$data"
                data=
                continue
elif [[ $char = ',' ]]; then
dbg "Element ends: %s" "$(peekContext)"

                writeData

                context=$(peekContext)
                popContext
                if isArray "$context"; then
pushContext "$((context + 1))"
                fi

dirty=1
                continue
elif [[ $char = [$' \n\r\t\v'] ]]; then
                # Ignore unquoted whitespace
                continue
fi
fi

data+=$char

    done
}
startJSONContext() {
    local context=$1
    dbg 'Starting context: %s' "$context"

    if isObject "$context"; then
printf "{'%s':" "$context"
    else
printf '['
    fi
}
endJSONContexts() {
    for (( p = $#; p > 0; --p )); do
context=${@:p:1}
        dbg 'Ending context: %s' "$context"

        if isObject "$context"; then
printf '}'
        else
printf ']'
        fi
done
}
# WIP
parsePlain() {
    firstElement=()
    while IFS= read -r -d "$delimitor"; do
key=${REPLY%%=*} data=${REPLY#*=}
        IFS='#.' read -r -a newContextStack <<< "$key"
        newContextStack=("${newContextStack[@]:1}")
        dbg 'key:%s data:<%s>' "$key" "$data"

        for s in "${!newContextStack[@]}"; do
newContext=${newContextStack[s]}
            if (( s >= ${#oldContextStack[@]} )); then
                # Start new context
                startJSONContext "$newContext"
                firstElement[s]=1
                dbg 'firstElements: %s' "${firstElement[*]}"
            #elif [[ ${oldContextStack[s]} != "$newContext" ]]; then
                # End old contexts up to s
                #endJSONContexts "${oldContextStack[@]:s}"
                #startJSONContext "$newContext"
                #firstElement=("${firstElement[@]:0:s}" 1)
                #dbg 'firstElements: %s' "${firstElement[*]}"
            fi
done
endJSONContexts "${oldContextStack[@]:s+1}"
        firstElement=("${firstElement[@]:0:s+1}")
                dbg 'firstElements: %s' "${firstElement[*]}"

        if (( ${firstElement[s]} )); then
printf '"%s"' "$data"
        else
printf ',"%s"' "$data"
        fi

firstElement[s]=0
        dbg 'firstElements: %s' "${firstElement[*]}"
        oldContextStack=("${newContextStack[@]}")
    done
endJSONContexts "${oldContextStack[@]}"
}

if (( jsonout )); then
parsePlain
else
parseJSON
fi
